# M 1262. 可被三整除的最大和

给你一个整数数组 `nums`，请你找出并返回能被三整除的元素最大和。



 

**示例 1：**

```
输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
```

**示例 2：**

```
输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
```

**示例 3：**

```
输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
```

 

**提示：**

- `1 <= nums.length <= 4 * 10^4`
- `1 <= nums[i] <= 10^4`

### 贪心

首先求和所有的数字，随后只有两种情况，除3余1和除3余2，尽可能减去少的数字，`1.减去一个余1的数字，2.减去两个余2的数字`这种方法都能够解决除3余1的问题，如果是除3余2则使用`1.减去一个余2的数字，2.减去两个余1的数字`的方法，这两种方法需要进行判断，怎样减少的是对总和最小的结果。如果这两种方法都不行，则说明没办法得到结果，返回0。

```cpp
class Solution {
public:
    int maxSumDivThree(vector<int> &nums) {
        int s = accumulate(nums.begin(), nums.end(), 0);
        if (s % 3 == 0)
            return s;

        vector<int> a[3];
        for (int x: nums)
            a[x % 3].push_back(x);
        sort(a[1].begin(), a[1].end());
        sort(a[2].begin(), a[2].end());

        if (s % 3 == 2)
            swap(a[1], a[2]);
        int ans = a[1].size() ? s - a[1][0] : 0;
        if (a[2].size() > 1)
            ans = max(ans, s - a[2][0] - a[2][1]);
        return ans;
    }
};
```


