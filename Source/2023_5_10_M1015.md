# M 1015. 可被 K 整除的最小整数

给定正整数 `k` ，你需要找出可以被 `k` 整除的、仅包含数字 `**1**` 的最 **小** 正整数 `n` 的长度。

返回 `n` 的长度。如果不存在这样的 `n` ，就返回-1。

**注意：** `n` 不符合 64 位带符号整数。

 

**示例 1：**

```
输入：k = 1
输出：1
解释：最小的答案是 n = 1，其长度为 1。
```

**示例 2：**

```
输入：k = 2
输出：-1
解释：不存在可被 2 整除的正整数 n 。
```

**示例 3：**

```
输入：k = 3
输出：3
解释：最小的答案是 n = 111，其长度为 3。
```

 

**提示：**

- `1 <= k <= 105`

### 取模

这个公式$(a+b) \% m=((a\%m)+(b\%m))\%m$很重要，是取模题目中很多要用到的。这里有一个判断重复的方法（哈希表）。

```cpp
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        unordered_set<int> seen;
        int x = 1 % k;//从1开始计算
        while (x && !seen.count(x)) {//每次循环前一定要判断此刻的余数是否已经为0 并且这个余数是否出现过
            seen.insert(x);//插入余数
            x = (x * 10 + 1) % k;//计算加上下一位的余数
        }
        return x ? -1 : seen.size()+1;//如果余数不为0，说明有重复无法整除，如果余数为零直接返回哈希表的长度+1（因为计数在取余判断后）
    }
};
```

