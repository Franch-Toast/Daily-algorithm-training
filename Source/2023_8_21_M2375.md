# M 2375. 根据模式串构造最小数字

给你下标从 **0** 开始、长度为 `n` 的字符串 `pattern` ，它包含两种字符，`'I'` 表示 **上升** ，`'D'` 表示 **下降** 。

你需要构造一个下标从 **0** 开始长度为 `n + 1` 的字符串，且它要满足以下条件：

- `num` 包含数字 `'1'` 到 `'9'` ，其中每个数字 **至多** 使用一次。
- 如果 `pattern[i] == 'I'` ，那么 `num[i] < num[i + 1]` 。
- 如果 `pattern[i] == 'D'` ，那么 `num[i] > num[i + 1]` 。

请你返回满足上述条件字典序 **最小** 的字符串 `num`。

 

**示例 1：**

```
输入：pattern = "IIIDIDDD"
输出："123549876"
解释：
下标 0 ，1 ，2 和 4 处，我们需要使 num[i] < num[i+1] 。
下标 3 ，5 ，6 和 7 处，我们需要使 num[i] > num[i+1] 。
一些可能的 num 的值为 "245639871" ，"135749862" 和 "123849765" 。
"123549876" 是满足条件最小的数字。
注意，"123414321" 不是可行解因为数字 '1' 使用次数超过 1 次。
```

**示例 2：**

```
输入：pattern = "DDD"
输出："4321"
解释：
一些可能的 num 的值为 "9876" ，"7321" 和 "8742" 。
"4321" 是满足条件最小的数字。
```

 

**提示：**

- `1 <= pattern.length <= 8`
- `pattern` 只包含字符 `'I'` 和 `'D'` 。





### 贪心

每次在遍历中寻找连续的 `I`，连续的 `D`，为了保证连续的段的最小字典序，所以该段的字典序一定是当前尽可能小的 `456`，或`654`这种形式，所以只要在过程中找到连续的段即可。其实这题有更优雅的做法，就是初始的字符串都是`123456789`这样的升序，找到连续的`D`，并把该递减段对应的字符串反序即可。

```cpp
class Solution {
public:
    string smallestNumber(string pattern) {
        int i = 0, n = pattern.length();
        char cur = '1';
        string ans(n + 1, 0);
        while (i < n) {
            if (i && pattern[i] == 'I') ++i;
            for (; i < n && pattern[i] == 'I'; ++i) ans[i] = cur++;//从前向后把递增的部分填充上，然后继续找递减的部分
            int i0 = i;
            while (i < n && pattern[i] == 'D') ++i;
            // i0 - i 都是'D'
            for (int j = i; j >= i0; --j) ans[j] = cur++; //从后向前把递减的部分填充上，然后再次进入循环寻找递增递减序列
        }
        return ans;
    }
};

```


