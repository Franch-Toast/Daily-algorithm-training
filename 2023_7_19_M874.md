# M 874. 模拟行走机器人

机器人在一个无限大小的 XY 网格平面上行走，从点 `(0, 0)` 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 `commands` ：

- `-2` ：向左转 `90` 度
- `-1` ：向右转 `90` 度
- `1 <= x <= 9` ：向前移动 `x` 个单位长度

在网格上有一些格子被视为障碍物 `obstacles` 。第 `i` 个障碍物位于网格点  `obstacles[i] = (xi, yi)` 。

机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。

返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 `5` ，则返回 `25` ）

 

**注意：**

- 北表示 `+Y` 方向。
- 东表示 `+X` 方向。
- 南表示 `-Y` 方向。
- 西表示 `-X` 方向。

 

**示例 1：**

```
输入：commands = [4,-1,3], obstacles = []
输出：25
解释：
机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 3 个单位，到达 (3, 4)
距离原点最远的是 (3, 4) ，距离为 32 + 42 = 25
```

**示例 2：**

```
输入：commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出：65
解释：机器人开始位于 (0, 0)：
1. 向北移动 4 个单位，到达 (0, 4)
2. 右转
3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)
4. 左转
5. 向北走 4 个单位，到达 (1, 8)
距离原点最远的是 (1, 8) ，距离为 12 + 82 = 65
```

 

**提示：**

- `1 <= commands.length <= 104`
- `commands[i]` is one of the values in the list `[-2,-1,1,2,3,4,5,6,7,8,9]`.
- `0 <= obstacles.length <= 104`
- `-3 * 104 <= xi, yi <= 3 * 104`
- 答案保证小于 `231`



### 哈希表+模拟

这里比较值得注意的是，将二维的坐标保存在哈希表内的时候，使用了约定好的一种计算方式保存为一维的形式，其中很重要的是，这种计算方式得到的数一定要是唯一的。

在模拟的过程中，用一个变量来维护行走方向，在确定行走方向后，一步一步递进地走，一步一步判断是否碰到了障碍物。

```cpp
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        int dirs[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};//方向顺序很重要，从左到右按照向右转的顺序
        int px = 0, py = 0, d = 1;//定义当前坐标以及当前方向，初始面向方向向前
        unordered_set<int> mp;
        for (auto &obstacle : obstacles) {
            mp.emplace(obstacle[0] * 60001 + obstacle[1]);//以一维的形式保存障碍物坐标
        }
        int res = 0;
        for (int c : commands) {
            if (c < 0) {//如果进行专项
                d += c == -1 ? 1 : -1;//右转方向+1，左转方向减1
                d %= 4;//4次转向为1周
                if (d < 0) {
                    d += 4;//如果方向为负，则+4为正（要进行方向索引）
                }
            } else {
                for (int i = 0; i < c; i++) {
                    if (mp.count((px + dirs[d][0]) * 60001 + py + dirs[d][1])) {//一步一步来进行查找，并使用此前约定好的一位形式来判断是否会碰到障碍物
                        break;
                    }
                    px += dirs[d][0];
                    py += dirs[d][1];
                    res = max(res, px * px + py * py);//维护最远距离
                }
            }
        }
        return res;
    }
};
```


